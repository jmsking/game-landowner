#! /usr/bin/env python

import numpy as np
import config
from hand_card_utils import HandCardUtils
from all_card import CARD_MAP

"""
Preprocess Utils
"""

"""
Generate state-action pair based the process of putting card
Ref. Table 1 of paper
Args:
  card_process: the process of putting card
    Ex. 0,33;1,55;2,66...
  target: labeled target
    Ex. 0 or 1 or 2
"""
def gen_state_action_pair(card_process, target=1):
    samples = list()
    one_sample = list()
    put_seq = card_process.split(";")
    for item in put_seq:
        one_sample.append(item)
        player, _ = item.strip().split(",")
        if player == str(target):
            if len(one_sample) > 1:
                samples.append(one_sample.copy())
           
    return samples

"""
Generate the input of policy network
Args:
  one_record: generated by method <gen_state_action_pair>
Returns:
  the shape of result is 15*19*21
"""
def gen_policy_net_input(samples):
    train_inputs = list()
    rounds = len(samples)
    for ix, sample in enumerate(samples):
        hand_card_status = [4]*13 + [1] + [1]
        one_input = np.zeros([15,19,21])
        if ix < rounds - config.LAST_ROUND_NO:
            for item in sample[:-1]:
                _, put_card = item.split(",")
                atype, card_dict = _decode_put_card(put_card)
                # All played out cards before last 6 rounds
                for card, num in card_dict.values():
                    one_input[card-3][num-1][0] = 1
                    one_input[card-3][atype][0] = 1
                    hand_card_status[card-3] -= num
            # All cards that have not been seen yet
            unseen_cards = list(filter(lambda x:x[1]==4 or (x[1]==1 and x[0] in (13,14)), 
                        enumerate(hand_card_status)))
            for card, num in unseen_cards:
                one_input[card-3][num-1][20] = 1
            # All cards in hand
            in_hand_cards = list(filter(lambda x:x[1]>0, enumerate(hand_card_status)))
            for card, num in in_hand_cards:
                one_input[card-3][num-1][21] = 1
        # process the last <config.LAST_ROUND_NO> rounds
        else:
            for item in sample[:-1]:
                _, put_card = item.split(",")
                atype, card_dict = _decode_put_card(put_card)
                for card, num in card_dict.values():
                    one_input[card-3][num-1][0] = 1
                    one_input[card-3][atype][0] = 1
                    hand_card_status[card-3] -= num
            # All cards that have not been seen yet
            unseen_cards = list(filter(lambda x:x[1]==4 or (x[1]==1 and x[0] in (13,14)), 
                        enumerate(hand_card_status)))
            for card, num in unseen_cards:
                one_input[card-3][num-1][20] = 1
            # All cards in hand
            in_hand_cards = list(filter(lambda x:x[1]>0, enumerate(hand_card_status)))
            for card, num in in_hand_cards:
                one_input[card-3][num-1][21] = 1

"""
Decode the card played out
Args:
  put_card: Ex. '33', '789TJ'
Returns:
  
"""
def _decode_put_card(put_card):
    atype, card_dict = HandCardUtils.decode_put_card(None)
    if put_card != "PASS":
        put_card_list = list(map(lambda x:CARD_MAP[x], put_card))
        atype, card_dict = HandCardUtils.decode_put_card(put_card_list)
    return atype, card_dict

if __name__ == "__main__":
    card_process = HandCardUtils.read_from_file()[0]
    print(card_process)
    samples = gen_state_action_pair(card_process, target=0)
    print(samples)