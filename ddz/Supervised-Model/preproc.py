#! /usr/bin/env python

import numpy as np
import config
from hand_card_utils import HandCardUtils
from all_card import CARD_MAP

"""
Preprocess Utils
"""
class PreprocUtils(object):

    @staticmethod
    def gen_policy_net_input():
        card_process = HandCardUtils.read_from_file()[0]
        samples = PreprocUtils._gen_state_action_pair(card_process, target=0)
        train_inputs, train_output = PreprocUtils._gen_policy_net_input_core(samples)
        return train_inputs, train_output

    """
    Generate state-action pair based the process of putting card
    Ref. Table 1 of paper
    Args:
    card_process: the process of putting card
        Ex. 0,33;1,55;2,66...
    target: labeled target
        Ex. 0 or 1 or 2
    """
    @staticmethod
    def _gen_state_action_pair(card_process, target=1):
        samples = list()
        one_sample = list()
        put_seq = card_process.split(";")
        for item in put_seq:
            one_sample.append(item)
            player, _ = item.strip().split(",")
            if player == str(target):
                if len(one_sample) > 1:
                    samples.append(one_sample.copy())
            
        return samples

    """
    Generate the input of policy network
    Args:
    one_record: generated by method <gen_state_action_pair>
    Returns:
    the shape of result is 15*19*21
    """
    @staticmethod
    def _gen_policy_net_input_core(samples):
        train_inputs = list()
        train_output = list()
        for sample in samples:
            one_input = np.zeros([15,4,3])
            for item in sample[:-1]:
                role, put_card = item.split(",")
                role = int(role)
                _, card_dict = PreprocUtils._decode_put_card(put_card)
                for card in card_dict:
                    num = card_dict[card]
                    one_input[card-3][num-1][role] = 1
            train_inputs.append(one_input)
            role, put_card = sample[-1].split(",")
            atype, _ = PreprocUtils._decode_put_card(put_card)
            train_output.append([atype])
        return np.array(train_inputs), np.array(train_output)

    """
    Decode the card played out
    Args:
    put_card: Ex. '33', '789TJ'
    Returns:
    
    """
    @staticmethod
    def _decode_put_card(put_card):
        atype, card_dict = HandCardUtils.decode_put_card(None)
        if put_card != "PASS":
            atype, card_dict = HandCardUtils.decode_put_card(put_card)
        return atype, card_dict

if __name__ == "__main__":
    train_inputs, train_output = PreprocUtils.gen_policy_net_input()
    print(train_inputs.shape)
    print(train_output.shape)